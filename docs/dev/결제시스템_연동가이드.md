# Fryndo 결제 시스템 연동 가이드

> 토스페이먼츠 결제 API 연동 (Spring Boot)

---

## 1. 토스페이먼츠 가입 및 설정

### 1.1 가입 절차

1. **개발자센터 가입**: https://developers.tosspayments.com
2. **사업자 인증** (필요 서류):
   - 사업자등록증
   - 통신판매업 신고증
   - 대표자 신분증 사본
3. **심사 완료** (3-5 영업일)
4. **상용 API 키 발급**

### 1.2 API 키 정보

```yaml
# application.yml

toss:
  payments:
    # 테스트 환경
    test:
      secret-key: test_sk_XXXXXXXXXXXXXXX
      client-key: test_ck_XXXXXXXXXXXXXXX
    # 상용 환경
    live:
      secret-key: live_sk_XXXXXXXXXXXXXXX
      client-key: live_ck_XXXXXXXXXXXXXXX

    # 현재 사용 환경
    mode: test  # test 또는 live
```

---

## 2. 의존성 추가

### 2.1 Gradle (build.gradle)

```gradle
dependencies {
    // HTTP Client
    implementation 'org.springframework.boot:spring-boot-starter-webflux'

    // JSON 처리
    implementation 'com.fasterxml.jackson.core:jackson-databind'

    // 결제 관련 유틸리티
    implementation 'commons-codec:commons-codec:1.15'
}
```

### 2.2 Maven (pom.xml)

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>
</dependencies>
```

---

## 3. 결제 설정 클래스

### 3.1 TossPaymentsConfig.java

```java
package com.travelmate.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import lombok.Getter;
import lombok.Setter;

@Configuration
@ConfigurationProperties(prefix = "toss.payments")
@Getter
@Setter
public class TossPaymentsConfig {

    private String mode;
    private TestConfig test;
    private LiveConfig live;

    @Getter @Setter
    public static class TestConfig {
        private String secretKey;
        private String clientKey;
    }

    @Getter @Setter
    public static class LiveConfig {
        private String secretKey;
        private String clientKey;
    }

    public String getSecretKey() {
        return "live".equals(mode) ? live.getSecretKey() : test.getSecretKey();
    }

    public String getClientKey() {
        return "live".equals(mode) ? live.getClientKey() : test.getClientKey();
    }

    public boolean isTestMode() {
        return "test".equals(mode);
    }
}
```

---

## 4. 결제 서비스 구현

### 4.1 TossPaymentsService.java

```java
package com.travelmate.service;

import com.travelmate.config.TossPaymentsConfig;
import com.travelmate.dto.payment.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Service
@RequiredArgsConstructor
@Slf4j
public class TossPaymentsService {

    private static final String TOSS_API_URL = "https://api.tosspayments.com/v1";

    private final TossPaymentsConfig config;
    private final WebClient webClient;

    /**
     * 결제 승인 요청
     */
    public PaymentResponse confirmPayment(PaymentConfirmRequest request) {
        log.info("결제 승인 요청: orderId={}, amount={}", request.getOrderId(), request.getAmount());

        return webClient.post()
            .uri(TOSS_API_URL + "/payments/confirm")
            .header(HttpHeaders.AUTHORIZATION, getAuthorizationHeader())
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .retrieve()
            .bodyToMono(PaymentResponse.class)
            .doOnSuccess(res -> log.info("결제 승인 완료: paymentKey={}", res.getPaymentKey()))
            .doOnError(e -> log.error("결제 승인 실패: {}", e.getMessage()))
            .block();
    }

    /**
     * 결제 취소 요청
     */
    public PaymentResponse cancelPayment(String paymentKey, PaymentCancelRequest request) {
        log.info("결제 취소 요청: paymentKey={}, reason={}", paymentKey, request.getCancelReason());

        return webClient.post()
            .uri(TOSS_API_URL + "/payments/" + paymentKey + "/cancel")
            .header(HttpHeaders.AUTHORIZATION, getAuthorizationHeader())
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .retrieve()
            .bodyToMono(PaymentResponse.class)
            .doOnSuccess(res -> log.info("결제 취소 완료"))
            .doOnError(e -> log.error("결제 취소 실패: {}", e.getMessage()))
            .block();
    }

    /**
     * 결제 조회
     */
    public PaymentResponse getPayment(String paymentKey) {
        return webClient.get()
            .uri(TOSS_API_URL + "/payments/" + paymentKey)
            .header(HttpHeaders.AUTHORIZATION, getAuthorizationHeader())
            .retrieve()
            .bodyToMono(PaymentResponse.class)
            .block();
    }

    /**
     * 빌링키 발급 (자동 결제용)
     */
    public BillingKeyResponse issueBillingKey(BillingKeyRequest request) {
        log.info("빌링키 발급 요청: customerKey={}", request.getCustomerKey());

        return webClient.post()
            .uri(TOSS_API_URL + "/billing/authorizations/issue")
            .header(HttpHeaders.AUTHORIZATION, getAuthorizationHeader())
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .retrieve()
            .bodyToMono(BillingKeyResponse.class)
            .doOnSuccess(res -> log.info("빌링키 발급 완료: billingKey={}", res.getBillingKey()))
            .block();
    }

    /**
     * 빌링키로 자동 결제
     */
    public PaymentResponse billPayment(String billingKey, BillingPaymentRequest request) {
        log.info("자동 결제 요청: billingKey={}, amount={}", billingKey, request.getAmount());

        return webClient.post()
            .uri(TOSS_API_URL + "/billing/" + billingKey)
            .header(HttpHeaders.AUTHORIZATION, getAuthorizationHeader())
            .contentType(MediaType.APPLICATION_JSON)
            .bodyValue(request)
            .retrieve()
            .bodyToMono(PaymentResponse.class)
            .doOnSuccess(res -> log.info("자동 결제 완료: paymentKey={}", res.getPaymentKey()))
            .block();
    }

    private String getAuthorizationHeader() {
        String credentials = config.getSecretKey() + ":";
        String encoded = Base64.getEncoder().encodeToString(
            credentials.getBytes(StandardCharsets.UTF_8)
        );
        return "Basic " + encoded;
    }
}
```

---

## 5. DTO 클래스

### 5.1 PaymentConfirmRequest.java

```java
package com.travelmate.dto.payment;

import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class PaymentConfirmRequest {
    private String paymentKey;
    private String orderId;
    private Long amount;
}
```

### 5.2 PaymentResponse.java

```java
package com.travelmate.dto.payment;

import lombok.Data;
import java.time.LocalDateTime;

@Data
public class PaymentResponse {
    private String paymentKey;
    private String orderId;
    private String orderName;
    private String status;
    private Long totalAmount;
    private Long balanceAmount;
    private String method;
    private LocalDateTime requestedAt;
    private LocalDateTime approvedAt;

    // 카드 정보
    private CardInfo card;

    // 취소 정보
    private CancelInfo[] cancels;

    @Data
    public static class CardInfo {
        private String company;
        private String number;
        private String installmentPlanMonths;
        private String approveNo;
        private String cardType;
    }

    @Data
    public static class CancelInfo {
        private Long cancelAmount;
        private String cancelReason;
        private LocalDateTime canceledAt;
    }
}
```

### 5.3 구독 관련 DTO

```java
// SubscriptionPlan.java
package com.travelmate.dto.payment;

import lombok.Getter;
import lombok.RequiredArgsConstructor;

@Getter
@RequiredArgsConstructor
public enum SubscriptionPlan {
    FREE("free", "무료", 0L),
    PLUS("plus", "Plus", 9900L),
    PRO("pro", "Pro", 19900L);

    private final String code;
    private final String name;
    private final Long price;
}

// BillingKeyRequest.java
@Data
@Builder
public class BillingKeyRequest {
    private String customerKey;
    private String authKey;
}

// BillingPaymentRequest.java
@Data
@Builder
public class BillingPaymentRequest {
    private String customerKey;
    private Long amount;
    private String orderId;
    private String orderName;
    private String customerEmail;
    private String customerName;
}
```

---

## 6. 결제 컨트롤러

### 6.1 PaymentController.java

```java
package com.travelmate.controller;

import com.travelmate.dto.payment.*;
import com.travelmate.service.TossPaymentsService;
import com.travelmate.service.SubscriptionService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/payments")
@RequiredArgsConstructor
@Slf4j
public class PaymentController {

    private final TossPaymentsService paymentsService;
    private final SubscriptionService subscriptionService;

    /**
     * 결제 승인 (프론트에서 결제 완료 후 호출)
     */
    @PostMapping("/confirm")
    public ResponseEntity<?> confirmPayment(@RequestBody PaymentConfirmRequest request) {
        try {
            // 1. 주문 정보 검증
            if (!subscriptionService.validateOrder(request.getOrderId(), request.getAmount())) {
                return ResponseEntity.badRequest().body("주문 정보가 일치하지 않습니다.");
            }

            // 2. 결제 승인
            PaymentResponse response = paymentsService.confirmPayment(request);

            // 3. 구독 활성화
            subscriptionService.activateSubscription(request.getOrderId(), response);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("결제 승인 실패", e);
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    /**
     * 결제 취소 (환불)
     */
    @PostMapping("/{paymentKey}/cancel")
    public ResponseEntity<?> cancelPayment(
            @PathVariable String paymentKey,
            @RequestBody PaymentCancelRequest request) {
        try {
            PaymentResponse response = paymentsService.cancelPayment(paymentKey, request);

            // 구독 비활성화
            subscriptionService.deactivateSubscription(paymentKey);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("결제 취소 실패", e);
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    /**
     * 자동결제용 빌링키 발급
     */
    @PostMapping("/billing/issue")
    public ResponseEntity<?> issueBillingKey(@RequestBody BillingKeyRequest request) {
        try {
            BillingKeyResponse response = paymentsService.issueBillingKey(request);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            log.error("빌링키 발급 실패", e);
            return ResponseEntity.badRequest().body(e.getMessage());
        }
    }

    /**
     * 결제 위젯용 클라이언트 키 조회
     */
    @GetMapping("/client-key")
    public ResponseEntity<?> getClientKey() {
        return ResponseEntity.ok(Map.of(
            "clientKey", paymentsService.getClientKey()
        ));
    }
}
```

---

## 7. 프론트엔드 연동 (React)

### 7.1 결제 위젯 컴포넌트

```typescript
// PaymentWidget.tsx
import { useEffect, useRef, useState } from 'react';
import { loadTossPayments } from '@tosspayments/payment-sdk';

interface PaymentWidgetProps {
  orderId: string;
  orderName: string;
  amount: number;
  customerEmail: string;
  customerName: string;
  onSuccess: (paymentKey: string) => void;
  onFail: (error: Error) => void;
}

export const PaymentWidget: React.FC<PaymentWidgetProps> = ({
  orderId,
  orderName,
  amount,
  customerEmail,
  customerName,
  onSuccess,
  onFail,
}) => {
  const paymentWidgetRef = useRef<any>(null);
  const [clientKey, setClientKey] = useState<string>('');

  useEffect(() => {
    // 클라이언트 키 조회
    fetch('/api/payments/client-key')
      .then(res => res.json())
      .then(data => setClientKey(data.clientKey));
  }, []);

  useEffect(() => {
    if (!clientKey) return;

    const initWidget = async () => {
      const tossPayments = await loadTossPayments(clientKey);

      paymentWidgetRef.current = tossPayments.widgets({
        customerKey: customerEmail, // 또는 사용자 고유 ID
      });

      // 결제 UI 렌더링
      await paymentWidgetRef.current.setAmount({
        currency: 'KRW',
        value: amount,
      });

      await paymentWidgetRef.current.renderPaymentMethods({
        selector: '#payment-method',
        variantKey: 'DEFAULT',
      });

      await paymentWidgetRef.current.renderAgreement({
        selector: '#agreement',
        variantKey: 'AGREEMENT',
      });
    };

    initWidget();
  }, [clientKey, amount]);

  const handlePayment = async () => {
    try {
      await paymentWidgetRef.current.requestPayment({
        orderId,
        orderName,
        customerEmail,
        customerName,
        successUrl: `${window.location.origin}/payment/success`,
        failUrl: `${window.location.origin}/payment/fail`,
      });
    } catch (error) {
      onFail(error as Error);
    }
  };

  return (
    <div className="payment-widget">
      <div id="payment-method" />
      <div id="agreement" />
      <button onClick={handlePayment} className="payment-button">
        {amount.toLocaleString()}원 결제하기
      </button>
    </div>
  );
};
```

### 7.2 결제 성공 페이지

```typescript
// PaymentSuccess.tsx
import { useEffect, useState } from 'react';
import { useSearchParams, useNavigate } from 'react-router-dom';

export const PaymentSuccess: React.FC = () => {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');

  useEffect(() => {
    const confirmPayment = async () => {
      const paymentKey = searchParams.get('paymentKey');
      const orderId = searchParams.get('orderId');
      const amount = searchParams.get('amount');

      try {
        const response = await fetch('/api/payments/confirm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ paymentKey, orderId, amount: Number(amount) }),
        });

        if (response.ok) {
          setStatus('success');
          // 3초 후 마이페이지로 이동
          setTimeout(() => navigate('/mypage'), 3000);
        } else {
          setStatus('error');
        }
      } catch (error) {
        setStatus('error');
      }
    };

    confirmPayment();
  }, [searchParams, navigate]);

  if (status === 'loading') {
    return <div>결제 확인 중...</div>;
  }

  if (status === 'error') {
    return (
      <div>
        <h1>결제 실패</h1>
        <p>결제 처리 중 오류가 발생했습니다.</p>
        <button onClick={() => navigate('/pricing')}>다시 시도</button>
      </div>
    );
  }

  return (
    <div>
      <h1>결제 완료!</h1>
      <p>구독이 활성화되었습니다.</p>
      <p>잠시 후 마이페이지로 이동합니다...</p>
    </div>
  );
};
```

---

## 8. 구독 스케줄러 (자동 갱신)

### 8.1 SubscriptionScheduler.java

```java
package com.travelmate.scheduler;

import com.travelmate.entity.Subscription;
import com.travelmate.service.SubscriptionService;
import com.travelmate.service.TossPaymentsService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class SubscriptionScheduler {

    private final SubscriptionService subscriptionService;
    private final TossPaymentsService paymentsService;

    /**
     * 매일 자정에 만료 예정 구독 자동 갱신
     */
    @Scheduled(cron = "0 0 0 * * *")
    public void processAutoRenewal() {
        log.info("구독 자동 갱신 시작");

        LocalDate today = LocalDate.now();
        List<Subscription> expiringSubscriptions =
            subscriptionService.findExpiringSubscriptions(today);

        for (Subscription subscription : expiringSubscriptions) {
            try {
                // 빌링키로 자동 결제
                if (subscription.getBillingKey() != null) {
                    paymentsService.billPayment(
                        subscription.getBillingKey(),
                        BillingPaymentRequest.builder()
                            .customerKey(subscription.getUserId())
                            .amount(subscription.getPlan().getPrice())
                            .orderId(generateOrderId())
                            .orderName("Fryndo " + subscription.getPlan().getName() + " 구독")
                            .build()
                    );

                    // 구독 기간 연장
                    subscriptionService.extendSubscription(subscription.getId());
                    log.info("구독 자동 갱신 완료: userId={}", subscription.getUserId());
                }
            } catch (Exception e) {
                log.error("구독 자동 갱신 실패: userId={}", subscription.getUserId(), e);
                // 결제 실패 알림 발송
                subscriptionService.sendPaymentFailedNotification(subscription);
            }
        }

        log.info("구독 자동 갱신 완료: {}건 처리", expiringSubscriptions.size());
    }

    private String generateOrderId() {
        return "SUB_" + System.currentTimeMillis();
    }
}
```

---

## 9. 테스트 카드 정보

토스페이먼츠 테스트 환경에서 사용할 수 있는 테스트 카드:

| 카드 번호 | 유효기간 | CVC | 비밀번호 | 결과 |
|----------|---------|-----|---------|------|
| 4330000000000001 | 12/26 | 123 | 00 | 성공 |
| 4330000000000019 | 12/26 | 123 | 00 | 실패 |
| 4330000000000027 | 12/26 | 123 | 00 | 잔액부족 |

---

## 10. 체크리스트

### 개발 완료 후 확인사항

- [ ] 테스트 환경 결제 성공 확인
- [ ] 테스트 환경 결제 취소 확인
- [ ] 테스트 환경 자동결제(빌링) 확인
- [ ] 웹훅 수신 테스트
- [ ] 에러 처리 및 롤백 확인
- [ ] 결제 로그 저장 확인

### 상용 전환 전 확인사항

- [ ] 상용 API 키 발급 완료
- [ ] 환경변수 설정 (live 모드)
- [ ] 통신판매업 신고증 제출
- [ ] 이용약관/환불정책 URL 등록
- [ ] 결제 테스트 (실제 소액 결제)
- [ ] 결제 취소 테스트

---

> **다음 단계**: 위 코드를 Fryndo 프로젝트에 적용하고, 토스페이먼츠 개발자센터에서 테스트를 진행하세요.
